// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: links.sql

package database

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
)

const deleteLink = `-- name: DeleteLink :exec
UPDATE links SET deleted_at = NOW() WHERE id = $1
`

func (q *Queries) DeleteLink(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, deleteLink, id)
	return err
}

const getLink = `-- name: GetLink :one
SELECT id, original_url, short_code, custom_short_code, user_id, expired_at, created_at, updated_at, deleted_at FROM links WHERE user_id = $1 AND deleted_at IS NULL AND id = $2 LIMIT 1
`

type GetLinkParams struct {
	UserID uuid.UUID
	ID     uuid.UUID
}

func (q *Queries) GetLink(ctx context.Context, arg GetLinkParams) (Link, error) {
	row := q.db.QueryRowContext(ctx, getLink, arg.UserID, arg.ID)
	var i Link
	err := row.Scan(
		&i.ID,
		&i.OriginalUrl,
		&i.ShortCode,
		&i.CustomShortCode,
		&i.UserID,
		&i.ExpiredAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getLinks = `-- name: GetLinks :many
SELECT l.id, l.original_url, l.short_code, l.custom_short_code, l.user_id, l.expired_at, l.created_at, l.updated_at, l.deleted_at, COUNT(cl.id) as counts 
FROM links l
LEFT JOIN click_logs cl ON cl.code = l.short_code OR cl.code = l.custom_short_code
WHERE l.user_id = $1 AND l.deleted_at IS NULL
GROUP BY l.id
ORDER BY
  CASE WHEN $4::text = 'created_at' THEN l.created_at END DESC,
  CASE WHEN $4::text = 'updated_at' THEN l.updated_at END DESC,
  CASE WHEN $4::text = 'expired_at' THEN l.expired_at END DESC,
  CASE WHEN $4::text = 'counts' THEN COUNT(cl.id) END DESC
LIMIT $3
OFFSET $2
`

type GetLinksParams struct {
	UserID  uuid.UUID
	Offset  int32
	Limit   int32
	OrderBy string
}

type GetLinksRow struct {
	ID              uuid.UUID
	OriginalUrl     string
	ShortCode       string
	CustomShortCode sql.NullString
	UserID          uuid.UUID
	ExpiredAt       sql.NullTime
	CreatedAt       time.Time
	UpdatedAt       time.Time
	DeletedAt       sql.NullTime
	Counts          int64
}

func (q *Queries) GetLinks(ctx context.Context, arg GetLinksParams) ([]GetLinksRow, error) {
	rows, err := q.db.QueryContext(ctx, getLinks,
		arg.UserID,
		arg.Offset,
		arg.Limit,
		arg.OrderBy,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetLinksRow
	for rows.Next() {
		var i GetLinksRow
		if err := rows.Scan(
			&i.ID,
			&i.OriginalUrl,
			&i.ShortCode,
			&i.CustomShortCode,
			&i.UserID,
			&i.ExpiredAt,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.Counts,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRedirectLink = `-- name: GetRedirectLink :one
SELECT original_url FROM links WHERE short_code = $1 OR custom_short_code = $1
`

func (q *Queries) GetRedirectLink(ctx context.Context, shortCode string) (string, error) {
	row := q.db.QueryRowContext(ctx, getRedirectLink, shortCode)
	var original_url string
	err := row.Scan(&original_url)
	return original_url, err
}

const getTotalActiveLinks = `-- name: GetTotalActiveLinks :one
SELECT COUNT(*) as total FROM links l WHERE l.user_id = $1 AND l.deleted_at IS NULL
`

func (q *Queries) GetTotalActiveLinks(ctx context.Context, userID uuid.UUID) (int64, error) {
	row := q.db.QueryRowContext(ctx, getTotalActiveLinks, userID)
	var total int64
	err := row.Scan(&total)
	return total, err
}

const getTotalClicks = `-- name: GetTotalClicks :one
WITH click_counts AS (
    SELECT l.id, COUNT(cl.*) AS total_clicks
    FROM links l
    LEFT JOIN click_logs cl ON l.short_code = cl.code OR l.custom_short_code = cl.code
    WHERE l.user_id = $1 AND l.deleted_at IS NULL
    GROUP BY l.id
)
SELECT COALESCE(SUM(total_clicks), 0) AS total FROM click_counts
`

func (q *Queries) GetTotalClicks(ctx context.Context, userID uuid.UUID) (interface{}, error) {
	row := q.db.QueryRowContext(ctx, getTotalClicks, userID)
	var total interface{}
	err := row.Scan(&total)
	return total, err
}

const insertLink = `-- name: InsertLink :one
INSERT INTO links(
    original_url,
    short_code,
    custom_short_code,
    user_id,
    expired_at
) VALUES (
    $1, 
    $2, 
    $3, 
    $4, 
    $5
) 
RETURNING id, original_url, short_code, custom_short_code, user_id, expired_at, created_at, updated_at, deleted_at
`

type InsertLinkParams struct {
	OriginalUrl     string
	ShortCode       string
	CustomShortCode sql.NullString
	UserID          uuid.UUID
	ExpiredAt       sql.NullTime
}

func (q *Queries) InsertLink(ctx context.Context, arg InsertLinkParams) (Link, error) {
	row := q.db.QueryRowContext(ctx, insertLink,
		arg.OriginalUrl,
		arg.ShortCode,
		arg.CustomShortCode,
		arg.UserID,
		arg.ExpiredAt,
	)
	var i Link
	err := row.Scan(
		&i.ID,
		&i.OriginalUrl,
		&i.ShortCode,
		&i.CustomShortCode,
		&i.UserID,
		&i.ExpiredAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const updateLink = `-- name: UpdateLink :exec
UPDATE links SET custom_short_code = $1, original_url = $2, expired_at = $3 WHERE id = $1
`

type UpdateLinkParams struct {
	CustomShortCode sql.NullString
	OriginalUrl     string
	ExpiredAt       sql.NullTime
}

func (q *Queries) UpdateLink(ctx context.Context, arg UpdateLinkParams) error {
	_, err := q.db.ExecContext(ctx, updateLink, arg.CustomShortCode, arg.OriginalUrl, arg.ExpiredAt)
	return err
}
